import sanityClient from '@sanity/client';
import getImageUrlBuilder from '@sanity/image-url';
import React, { useState, useEffect } from 'react';
import { useDeepCompareEffectNoCheck } from 'use-deep-compare-effect';
import SanityPortableText from '@sanity/block-content-to-react';
export { default as groq } from 'groq';

function createClient(config) {
  return sanityClient(config);
}

function createImageUrlBuilder(_ref) {
  var projectId = _ref.projectId,
      dataset = _ref.dataset;
  return getImageUrlBuilder({
    projectId: projectId,
    dataset: dataset
  });
}

function getAborter() {
  return typeof AbortController === 'undefined' ? {
    signal: undefined,
    abort: noop
  } : new AbortController();
}

function noop() {// intentional noop
}

function createCurrentUserHook(_ref) {
  var projectId = _ref.projectId;
  return function () {
    return useCurrentUser(projectId);
  };
}
function getCurrentUser(projectId, abort) {
  return fetch("https://" + projectId + ".api.sanity.io/v1/users/me", {
    credentials: 'include',
    signal: abort == null ? void 0 : abort.signal
  }).then(function (res) {
    return res.json();
  }).then(function (res) {
    return res != null && res.id ? res : null;
  }).catch(function (err) {
    return err.name === 'AbortError' ? null : Promise.reject(err);
  });
}

function useCurrentUser(projectId) {
  var _useState = useState(),
      data = _useState[0],
      setUser = _useState[1];

  var _useState2 = useState(),
      error = _useState2[0],
      setError = _useState2[1];

  useEffect(function () {
    var aborter = getAborter();
    getCurrentUser(projectId, aborter).then(setUser).catch(setError);
    return function () {
      return aborter.abort();
    };
  }, [projectId]);
  return {
    data: data,
    error: error,
    loading: data !== null || !error
  };
}

var EMPTY_PARAMS = {};
function createPreviewSubscriptionHook(_ref) {
  var projectId = _ref.projectId,
      dataset = _ref.dataset,
      _ref$documentLimit = _ref.documentLimit,
      documentLimit = _ref$documentLimit === void 0 ? 3000 : _ref$documentLimit;
  // Only construct/setup the store when `getStore()` is called
  var store;
  return function usePreviewSubscription(query, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$params = _options.params,
        params = _options$params === void 0 ? EMPTY_PARAMS : _options$params,
        initialData = _options.initialData,
        enabled = _options.enabled;
    return useQuerySubscription({
      getStore: getStore,
      projectId: projectId,
      query: query,
      params: params,
      initialData: initialData,
      enabled: enabled ? typeof window !== 'undefined' : false
    });
  };

  function getStore() {
    if (!store) {
      store = import('@sanity/groq-store').then(function (_ref2) {
        var groqStore = _ref2.groqStore;
        return groqStore({
          projectId: projectId,
          dataset: dataset,
          documentLimit: documentLimit,
          listen: true,
          overlayDrafts: true,
          subscriptionThrottleMs: 10
        });
      });
    }

    return store;
  }
}

function useQuerySubscription(options) {
  var getStore = options.getStore,
      projectId = options.projectId,
      query = options.query,
      params = options.params,
      initialData = options.initialData,
      _options$enabled = options.enabled,
      enabled = _options$enabled === void 0 ? false : _options$enabled;

  var _useState = useState(),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = useState(false),
      loading = _useState2[0],
      setLoading = _useState2[1];

  var _useState3 = useState(),
      data = _useState3[0],
      setData = _useState3[1]; // Use "deep" dependency comparison because params are often not _referentially_ equal,
  // but contains the same shallow properties, eg `{"slug": "some-slug"}`


  useDeepCompareEffectNoCheck(function () {
    if (!enabled) {
      return function () {
        /* intentional noop */
      };
    }

    setLoading(true);
    var aborter = getAborter();
    var subscription;
    getCurrentUser(projectId, aborter).then(function (user) {
      if (user) {
        return;
      } // eslint-disable-next-line no-console


      console.warn('Not authenticated - preview not available');
      throw new Error('Not authenticated - preview not available');
    }).then(getStore).then(function (store) {
      subscription = store.subscribe(query, params, function (err, result) {
        if (err) {
          setError(err);
        } else {
          setData(result);
        }
      });
    }).catch(setError).finally(function () {
      return setLoading(false);
    });
    return function () {
      if (subscription) {
        subscription.unsubscribe();
      }

      aborter.abort();
    };
  }, [getStore, query, params, enabled]);
  return {
    data: typeof data === 'undefined' ? initialData : data,
    loading: loading,
    error: error
  };
}

function createPortableTextComponent(_ref) {
  var projectId = _ref.projectId,
      dataset = _ref.dataset,
      serializers = _ref.serializers;
  return function PortableText(props) {
    return React.createElement(SanityPortableText, Object.assign({
      projectId: projectId,
      dataset: dataset,
      serializers: serializers
    }, props));
  };
}

export { createClient, createCurrentUserHook, createImageUrlBuilder, createPortableTextComponent, createPreviewSubscriptionHook };
//# sourceMappingURL=next-sanity.esm.js.map
