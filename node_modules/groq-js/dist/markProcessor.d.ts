import { ParseOptions } from './types';
export declare type MarkName = 'add' | 'and' | 'arr_expr' | 'array_end' | 'array_splat' | 'array' | 'asc' | 'attr_ident' | 'comp' | 'dblparent' | 'deref_field' | 'deref' | 'desc' | 'div' | 'exc_range' | 'filter' | 'float' | 'func_args_end' | 'func_call' | 'ident' | 'inc_range' | 'integer' | 'mod' | 'mul' | 'neg' | 'not' | 'object_end' | 'object_expr' | 'object_pair' | 'object_splat_this' | 'object_splat' | 'object' | 'or' | 'pair' | 'param' | 'paren' | 'parent' | 'pipecall' | 'pos' | 'pow' | 'project' | 'sci' | 'star' | 'str_begin' | 'sub' | 'this';
export interface Mark {
    name: string;
    position: number;
}
export declare type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>;
export declare type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T;
export declare class MarkProcessor {
    private string;
    private marks;
    private index;
    parseOptions: ParseOptions;
    allowBoost: boolean;
    constructor(string: string, marks: Mark[], parseOptions: ParseOptions);
    hasMark(pos?: number): boolean;
    getMark(pos?: number): Mark;
    shift(): void;
    process<T>(visitor: MarkVisitor<T>): T;
    processString(): string;
    processStringEnd(): string;
    slice(len: number): string;
}
